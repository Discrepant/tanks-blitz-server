# Tank Battle Game Server

This project is the backend server for a multiplayer tank battle game. It features a microservice architecture with components for authentication and game logic, supporting both Python and C++ implementations for different parts of the system.

## Table of Contents

- [Project Goals](#project-goals)
- [Architecture Overview](#architecture-overview)
- [Directory Structure](#directory-structure)
- [Requirements](#requirements)
- [Installation](#installation)
- [Running the Application](#running-the-application)
- [Testing](#testing)
- [Contributing](#contributing)
- [Future Improvements](#future-improvements)

## Project Goals

*   **Создание масштабируемого и высокопроизводительного бэкенда:** Разработать серверную часть для многопользовательской игры в танковые сражения в реальном времени, способную выдерживать значительные нагрузки и обеспечивать минимальные задержки.
*   **Разделение на микросервисы:** Реализовать независимые сервисы для аутентификации пользователей и игровой логики, что упрощает разработку, тестирование, развертывание и масштабирование отдельных компонентов системы.
*   **Эффективное межсервисное взаимодействие с помощью gRPC:** Использовать gRPC для быстрой и надежной коммуникации между внутренними сервисами, например, между C++ TCP сервером аутентификации и Python gRPC сервисом аутентификации.
*   **Асинхронная обработка задач и потоковая передача событий:** Применять очереди сообщений, такие как Kafka (для потоковой передачи событий, например, истории сессий, игровых событий) и RabbitMQ (для асинхронной обработки команд игроков), для повышения отказоустойчивости и снижения связанности компонентов.
*   **Надежное хранение данных с Redis:** Использовать Redis в качестве быстрого и эффективного хранилища данных для пользовательских сессий, кеширования и другой оперативной информации, доступ к которому осуществляется из Python сервиса аутентификации.
*   **Поддержка контейнеризации и оркестрации:** Обеспечить возможность развертывания приложения с использованием Docker-контейнеров и управления ими с помощью Kubernetes для упрощения развертывания, масштабирования и управления в различных средах.
*   **Интеграция системы мониторинга:** Внедрить Prometheus для сбора и отображения метрик производительности и состояния различных компонентов системы, что помогает в своевременном обнаружении и диагностике проблем.
*   **Гибкость разработки и производительность с Python и C++:** Предложить реализации серверных компонентов как на Python (для скорости разработки и удобства), так и на C++ (для критически важных по производительности частей, таких как игровой сервер), чтобы сбалансировать скорость разработки и эффективность выполнения.

## Architecture Overview

Система спроектирована как набор взаимодействующих микросервисов, обеспечивающих различные аспекты игры и аутентификации.

1.  **Nginx (Концептуально):**
    *   **Роль:** Выполняет функции входной точки для всего трафика, обеспечивает SSL-терминацию, балансировку нагрузки между экземплярами сервисов и, потенциально, защиту от DDoS-атак.
    *   **Проксирование:** Направляет TCP-трафик на C++ TCP сервер аутентификации и TCP/UDP трафик на C++ игровой сервер. Конкретные порты и правила маршрутизации настраиваются в конфигурации Nginx.

2.  **Сервис Аутентификации:** Состоит из двух основных компонентов:
    *   **C++ TCP Auth Server (`auth_server_cpp`):**
        *   **Назначение:** Принимает первичные TCP-соединения от игровых клиентов для запросов на вход (логин) или регистрацию.
        *   **Взаимодействие:** Получает от клиента JSON-сообщения, парсит их и далее выступает в роли gRPC-клиента к Python Auth gRPC сервису для выполнения фактической логики аутентификации. Ответ от gRPC сервиса транслируется обратно клиенту через TCP.
        *   **Протокол:** TCP для связи с клиентом, gRPC для связи с Python Auth gRPC сервисом.
    *   **Python Auth gRPC Service (`auth_server`):**
        *   **Назначение:** Реализует основную логику аутентификации и управления пользователями. Обрабатывает gRPC-запросы от C++ TCP Auth Server.
        *   **Взаимодействие с Redis:** Через модуль `user_service.py` взаимодействует с Redis для создания, проверки и хранения учетных данных пользователей, а также управления сессиями.
        *   **Публикация событий:** Публикует события аутентификации (например, успешный вход, новая регистрация) в топик Kafka (`auth_events`) для последующего анализа или обработки другими сервисами.
        *   **Протокол:** gRPC.

3.  **Игровой Сервис (`game_server_cpp`):**
    *   **Реализация:** Полностью на C++ для обеспечения высокой производительности и низких задержек, критичных для игрового процесса в реальном времени.
    *   **Основные функции:** Управляет игровой логикой, сессиями игроков, движением танков, механикой боя, подсчетом очков и т.д.
    *   **Сетевое взаимодействие:**
        *   **TCP:** Используется для надежной передачи управляющих сообщений. Например, при входе игрока в игровой мир (после успешной аутентификации), создается TCP-сессия. Эта сессия может также инициировать вызовы к сервису аутентификации (через его gRPC интерфейс) для проверки токена сессии.
        *   **UDP:** Применяется для частых обновлений состояния игры, таких как координаты танков, информация о выстрелах и других действиях, где допустима потеря пакетов ради скорости доставки.
    *   **Обработка команд игрока:**
        *   Команды от игроков (например, "двигаться вперед", "стрелять") могут поступать через TCP или UDP обработчики.
        *   Эти команды далее публикуются в очередь RabbitMQ (`player_commands`).
        *   Специальный компонент `PlayerCommandConsumer` (также на C++) считывает команды из RabbitMQ и применяет их к соответствующим игровым сессиям и объектам (танкам). Это позволяет отделить получение команд от их обработки.
    *   **Публикация игровых событий:** Важные игровые события (например, начало/конец матча, изменение счета, уничтожение танка) публикуются в соответствующий топик Kafka (`game_events`, `player_sessions_history`) для сбора статистики, логирования или других целей.

4.  **Очереди Сообщений:**
    *   **Kafka (`core/message_broker_clients.py` для Python, `RdKafka::rdkafka++` для C++):**
        *   **Назначение:** Используется как распределенная потоковая платформа для агрегации логов, сбора метрик и потоковой передачи событий из различных сервисов.
        *   **Топики (примеры):** `auth_events`, `game_events`, `player_sessions_history` (история игровых сессий), `tank_coordinates_history` (для записи траекторий движения).
    *   **RabbitMQ (`pika` для Python, `rabbitmq::rabbitmq` (цель от `librabbitmq`) для C++):**
        *   **Назначение:** Применяется для асинхронной обработки задач и более традиционных сценариев обмена сообщениями между сервисами, где требуется гарантированная доставка и гибкая маршрутизация.
        *   **Очереди (примеры):** `player_commands` (для команд игроков, отправляемых в игровой сервер).

5.  **Хранилище Данных Redis (`core/redis_client.py`):**
    *   **Назначение:** Используется Python Auth gRPC сервисом для хранения и быстрого доступа к данным пользователей (например, хеши паролей, информация о профиле) и активных сессий. Может также применяться для кеширования часто запрашиваемых данных.

6.  **Мониторинг (`monitoring/`):**
    *   **Prometheus:** Настроен для сбора (scraping) метрик с различных компонентов приложения. В Python-сервисах это обычно делается с использованием библиотеки `prometheus_client`. Для C++ сервисов может потребоваться дополнительная интеграция (например, через специальную библиотеку или http-endpoint, предоставляющий метрики в формате Prometheus).
    *   **Цель:** Обеспечение наблюдаемости системы, отслеживание ее производительности и оперативное выявление проблем.

**Потоки данных (примеры):** (Содержимое этого подраздела оставлено без изменений, так как оно описывает логику высокого уровня)
*   **Регистрация пользователя:** ...
*   **Вход пользователя и начало игры:** ...
*   **Отправка команды игроком (например, движение):** ...

## Directory Structure
(Содержимое этого раздела оставлено без изменений, так как оно описывает структуру файлов, которая не менялась)
*   `auth_server/`: ...
*   ...

## Requirements

### Общие требования (Common)
*   **Git:** Система контроля версий для клонирования репозитория.
*   **Docker & Docker Compose:** Для сборки и запуска контейнеризированных сервисов (например, Kafka, RabbitMQ, Redis) и самого приложения.

### Python Development
*   **Python:** Рекомендуется версия 3.9 или новее. Убедитесь, что Python добавлен в `PATH`.
*   **PIP:** Менеджер пакетов Python (обычно устанавливается вместе с Python).
*   **Зависимости Python:** Полный список указан в файле `requirements.txt`. Ключевые библиотеки включают:
    *   `grpcio`, `grpcio-tools`: для gRPC.
    *   `redis`: для взаимодействия с Redis.
    *   `confluent-kafka`: для взаимодействия с Kafka.
    *   `pika`: для взаимодействия с RabbitMQ.
    *   `prometheus_client`: для метрик Prometheus.
    *   `pytest`, `pytest-asyncio`: для тестирования.
    *   `locust`: для нагрузочного тестирования.
    *   `passlib[bcrypt]`: для хеширования паролей.

### C++ Development
Для разработки C++ компонентов потребуется настроенное окружение.

**Общие для всех ОС (Linux, macOS, Windows):**
*   **Компилятор C++:** Поддерживающий стандарт C++17 (например, GCC 8+, Clang 6+, MSVC Visual Studio 2019+).
*   **CMake:** Система автоматизации сборки, версия 3.16 или новее. Убедитесь, что CMake добавлен в `PATH`.
*   **Для генерации gRPC кода:**
    *   **`protoc` (Protocol Buffers Compiler)** и **`grpc_cpp_plugin` (gRPC C++ Plugin)**: Эти инструменты необходимы для компиляции `.proto` файлов в C++ код.
        *   **При использовании `vcpkg` для установки `grpc` (рекомендуется для Windows),** `protoc` и `grpc_cpp_plugin` обычно устанавливаются и интегрируются автоматически. CMake должен их найти через тулчейн vcpkg.
        *   **Для Linux,** если gRPC устанавливается через системный менеджер пакетов (например, `apt`), убедитесь, что установлены пакеты `protobuf-compiler` и `grpc_cpp_plugin` (или аналогичные, например, `libgrpc-dev` может включать плагин).
        *   Если устанавливается вручную, `protoc` должен быть в `PATH`, а `grpc_cpp_plugin` должен быть доступен (часто находится рядом с `protoc` или его путь должен быть известен CMake).

**Зависимости C++ и их установка:**

Мы **настоятельно рекомендуем использовать менеджер пакетов `vcpkg`** ([https://github.com/microsoft/vcpkg](https://github.com/microsoft/vcpkg)) для установки C++ зависимостей, особенно на **Windows**, так как это значительно упрощает процесс и обеспечивает совместимость. Инструкции ниже ориентированы на `vcpkg`. Для **Linux** также можно использовать `vcpkg` или системные менеджеры пакетов (например, `apt`).

**1. Установка `vcpkg` (если еще не установлен):**
*   Клонируйте репозиторий `vcpkg` в удобное для вас место (например, `C:\dev\vcpkg` или `~/vcpkg`):
    ```bash
    git clone https://github.com/microsoft/vcpkg.git
    cd vcpkg 
    ```
*   Запустите скрипт начальной настройки:
    *   Windows (PowerShell или CMD): `.\bootstrap-vcpkg.bat`
    *   Linux/macOS: `./bootstrap-vcpkg.sh`
*   Интегрируйте `vcpkg` с вашей системой сборки. Это особенно важно для Visual Studio на Windows, чтобы CMake и MSBuild автоматически находили библиотеки, установленные через `vcpkg`:
    ```bash
    # Находясь в директории vcpkg
    .\vcpkg integrate install 
    ```

**2. Установка необходимых пакетов через `vcpkg` (для Windows x64):**
Все C++ зависимости для этого проекта управляются через `vcpkg`. Используйте следующую команду в PowerShell или CMD (находясь в директории `vcpkg`), чтобы установить все необходимые пакеты для архитектуры **x64 Windows**. Если вы собираете для другой платформы или архитектуры (например, Linux), измените триплет (`x64-windows`) соответствующим образом.
```powershell
.\vcpkg install boost:x64-windows grpc:x64-windows librdkafka[cpp]:x64-windows librabbitmq:x64-windows nlohmann-json:x64-windows catch2:x64-windows openssl:x64-windows zlib:x64-windows c-ares:x64-windows re2:x64-windows
```
*   **Описание устанавливаемых пакетов:**
    *   `boost:x64-windows`: Набор библиотек C++ (в проекте используются компоненты Asio, System).
    *   `grpc:x64-windows`: Фреймворк gRPC (включает Protocol Buffers и необходимые инструменты, такие как `protoc` и `grpc_cpp_plugin`).
    *   `librdkafka[cpp]:x64-windows`: Клиентская библиотека Apache Kafka для C/C++ (с C++ оберткой, указанной через `[cpp]`).
    *   `librabbitmq:x64-windows`: Клиентская C-библиотека для RabbitMQ. (Примечание: CMake будет искать этот пакет как `rabbitmq-c` через `find_package`).
    *   `nlohmann-json:x64-windows`: Популярная библиотека для работы с JSON в C++.
    *   `catch2:x64-windows`: Фреймворк для юнит-тестирования C++.
    *   `openssl:x64-windows`: Криптографическая библиотека (часто является зависимостью для других библиотек, включая gRPC и Kafka).
    *   `zlib:x64-windows`: Библиотека для сжатия данных (часто является зависимостью).
    *   `c-ares:x64-windows`: C-библиотека для асинхронных DNS запросов (зависимость gRPC).
    *   `re2:x64-windows`: Библиотека для работы с регулярными выражениями (зависимость gRPC).
*   **Примечание о триплете:** Убедитесь, что используемый триплет (например, `:x64-windows`) соответствует вашей целевой архитектуре и конфигурации сборки. Для других платформ используйте соответствующие триплеты (например, `x64-linux`, `x64-osx`).

**3. Для Linux (альтернатива с `apt` для Debian/Ubuntu):**
Если вы не используете `vcpkg` на Linux, вы можете установить зависимости через `apt`. Имена пакетов могут немного отличаться, и вам нужно будет убедиться в их совместимости. Это примерный список:
```bash
sudo apt-get update
sudo apt-get install build-essential cmake git pkg-config \
    libboost-dev libboost-system-dev \
    libgrpc++-dev libprotobuf-dev protobuf-compiler grpc_cpp_plugin \
    librdkafka-dev \
    librabbitmq-dev \
    nlohmann-json3-dev \
    catch2 \
    libssl-dev zlib1g-dev libc-ares-dev libre2-dev
```
*При использовании системных менеджеров пакетов, убедитесь, что версии устанавливаемых библиотек совместимы с требованиями проекта и между собой.*

## Installation

### 1. Клонирование репозитория
```bash
git clone <URL_вашего_репозитория> # Замените на URL вашего репозитория
cd <имя_каталога_проекта>
```

### 2. Настройка Python окружения
Рекомендуется использовать виртуальное окружение для изоляции зависимостей проекта.

*   **Создание и активация виртуального окружения:**
    *   Linux/macOS:
        ```bash
        python3 -m venv venv
        source venv/bin/activate
        ```
    *   Windows (CMD/PowerShell):
        ```bash
        python -m venv venv
        .\venv\Scripts\activate  # Для PowerShell. Для CMD: venv\Scripts\activate.bat
        ```
*   **Установка Python зависимостей:**
    ```bash
    # Находясь в активированном виртуальном окружении
    pip install -r requirements.txt
    ```

### 3. Установка C++ зависимостей
Процесс установки C++ зависимостей подробно описан в разделе [C++ Development -> Зависимости C++ и их установка](#c-dependencies-and-installation). Пожалуйста, следуйте инструкциям в этом разделе, чтобы установить все необходимые компоненты с использованием `vcpkg` (рекомендуется) или системного менеджера пакетов для вашей ОС.

### 4. Генерация gRPC кода
CMake проект настроен на автоматическую генерацию C++ кода из `.proto` файлов (`cpp/protos/`) во время процесса конфигурации/сборки.
Если вы используете `vcpkg` и установили пакет `grpc` (как рекомендовано выше), все необходимые инструменты (`protoc` и `grpc_cpp_plugin`) должны быть автоматически обнаружены CMake через тулчейн-файл `vcpkg.cmake`. Никаких дополнительных действий по настройке `protoc` вручную обычно не требуется.

### 5. Сборка C++ компонентов
Сборка C++ компонентов осуществляется с помощью CMake. Процесс состоит из двух этапов: конфигурация (генерация сборочных файлов для вашей среды) и сама сборка.

**Общий процесс (из корневого каталога проекта):**
1.  Перейдите в каталог `cpp`:
    ```bash
    cd cpp
    ```
2.  Создайте каталог для сборки (например, `build`) и перейдите в него:
    ```bash
    mkdir build
    cd build
    ```
    *Все последующие команды CMake и сборки выполняются из каталога `cpp/build/`.*

**Конфигурация и сборка для Windows (Visual Studio с использованием `vcpkg`):**

*   **Предварительно:** Убедитесь, что `vcpkg integrate install` был выполнен после установки `vcpkg` и всех пакетов.
*   **Конфигурация (генерация проекта Visual Studio):**
    Откройте PowerShell или Developer Command Prompt for Visual Studio. Находясь в каталоге `cpp/build/`, выполните:
    ```powershell
    cmake .. -G "Visual Studio 17 2022" -A x64 -DCMAKE_TOOLCHAIN_FILE="C:/Users/Hoshi/vcpkg/scripts/buildsystems/vcpkg.cmake"
    ```
    *   **Важно:** Замените `C:/Users/Hoshi/vcpkg` на **актуальный путь** к вашему каталогу установки `vcpkg`. Путь должен быть абсолютным.
    *   Замените `"Visual Studio 17 2022"` на вашу версию Visual Studio, если она отличается (например, `"Visual Studio 16 2019"`). Список доступных генераторов можно посмотреть командой `cmake --help`.
    *   `-A x64` указывает на сборку под 64-битную архитектуру.
*   **Сборка:**
    *   **Через CMake (рекомендуется для командной строки):**
        ```powershell
        # Находясь в cpp/build/
        cmake --build . --config Release 
        ```
        Или для отладочной сборки:
        ```powershell
        cmake --build . --config Debug
        ```
    *   **Через Visual Studio IDE:**
        Откройте сгенерированный файл решения (`TankGameCppServices.sln` или аналогичный) в каталоге `cpp/build/` с помощью Visual Studio. Затем выберите конфигурацию (Debug/Release) и платформу (x64) и соберите решение (Build -> Build Solution).

**Конфигурация и сборка для Linux/macOS (GCC/Clang):**
```bash
# Находясь в cpp/build/

# Конфигурация (если используете vcpkg, не забудьте CMAKE_TOOLCHAIN_FILE):
# cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=[путь_к_vcpkg]/scripts/buildsystems/vcpkg.cmake 
# Или без vcpkg, если зависимости установлены системно:
cmake .. -DCMAKE_BUILD_TYPE=Release

# Сборка:
make -j$(nproc) # Используйте количество ядер вашего процессора
# Или cmake --build . --config Release
```

**Результаты сборки:**
Исполняемые файлы для C++ сервера аутентификации, игрового сервера и тестов будут находиться в соответствующих подкаталогах внутри `cpp/build/` (например, `cpp/build/auth_server_cpp/Release/auth_server_app.exe` и `cpp/build/game_server_cpp/Release/game_server_app.exe` для Windows Release сборки, или `cpp/build/auth_server_cpp/auth_server_app` для Linux).

**Политики CMake (CMP0167 - FindBoost):**
В CMake-скрипты проекта (`game_server_cpp/CMakeLists.txt`, `auth_server_cpp/CMakeLists.txt`, `tests/CMakeLists.txt`) добавлена команда `cmake_policy(SET CMP0167 NEW)` перед поиском пакета Boost. Это сделано для использования нового поведения модуля `FindBoost` и устранения соответствующих предупреждений CMake. Пользователю не требуется предпринимать дополнительных действий по этому поводу.

### 6. Установка Docker (для инфраструктурных сервисов)
(Содержимое этого подраздела оставлено без изменений)
*   **Docker Desktop для Windows/macOS:** ...
*   **Docker для Linux:** ...

## Running the Application
(Содержимое этого раздела оставлено без значительных изменений, но стоит проверить актуальность портов и имен переменных окружения, если они менялись в C++ коде)
...

## Testing
(Содержимое этого раздела оставлено без значительных изменений, но стоит проверить пути к исполняемым файлам тестов и команды их запуска)
...

## Contributing
(Содержимое этого раздела оставлено без изменений)
...

## Future Improvements
(Содержимое этого раздела оставлено без изменений)
...
