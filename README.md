# Серверная архитектура Tanks Blitz (Прототип)

Этот проект представляет собой прототип серверной архитектуры для многопользовательской игры Tanks Blitz, разработанный на Python.
Он включает компоненты для аутентификации, игровой логики, обработки команд через брокеры сообщений, масштабирования, мониторинга и резервного копирования.

## Обзор проекта

Цель проекта - продемонстрировать построение серверной части для MMO-игры с учетом современных практик и технологий, таких как:
- Разделение сервисов (аутентификация, игра)
- Асинхронное программирование и обработка событий
- Брокеры сообщений (Kafka, RabbitMQ) для асинхронных задач и логирования
- Паттерны проектирования (Singleton, Object Pool)
- Контейнеризация (Docker)
- Оркестрация (Kubernetes)
- Мониторинг (Prometheus, Grafana)
- Защита от DDoS (Nginx)
- Резервное копирование (Redis)

## Архитектура

Система состоит из следующих основных компонентов:

1.  **Клиент Игры** (не входит в этот репозиторий)
2.  **Nginx (Входная точка/Балансировщик/Защита от DDoS):**
    *   Принимает весь трафик от клиентов.
    *   Проксирует TCP-трафик на Сервер Аутентификации.
    *   Проксирует UDP-трафик на Игровой Сервер.
    *   Может быть настроен для базовой защиты от DDoS.
    *   Разворачивается в Kubernetes.
3.  **Сервер Аутентификации (Auth Server):**
    *   **Протокол: TCP, JSON.** (Описание без изменений)
    *   Назначение: Регистрация и аутентификация. Отправляет события аудита в Kafka.
    *   Технологии: Python, `asyncio`, Kafka-клиент.
    *   Экспортирует метрики для Prometheus на порт `8000`.
4.  **Игровой Сервер (Game Server):**
    *   **Протокол: UDP (основной игровой), TCP (управляющие команды). Сообщения в формате JSON.** (Описание без изменений)
    *   Назначение: Обработка игровой логики, синхронизация состояния игры. Взаимодействует с RabbitMQ для получения команд игроков и событий матчмейкинга. Отправляет события состояния игры и данные в Kafka.
    *   Паттерны: `SessionManager` (Singleton), `TankPool` (Object Pool).
    *   Компоненты:
        *   `udp_handler.py`, `tcp_handler.py`: Обработка входящих команд, публикация в RabbitMQ.
        *   `command_consumer.py`: Содержит `PlayerCommandConsumer` (обработка команд из RabbitMQ) и `MatchmakingEventConsumer` (обработка событий матчмейкинга из RabbitMQ).
        *   `session_manager.py`, `tank_pool.py`, `tank.py`: Основная игровая логика, отправка событий в Kafka.
    *   Технологии: Python, `asyncio`, Kafka-клиент, Pika (RabbitMQ-клиент).
    *   Экспортирует метрики для Prometheus на порт `8001`.
5.  **Kafka (Брокер сообщений):**
    *   Назначение: Сбор и хранение событий от различных компонентов системы для логирования, аналитики и потенциальной последующей обработки.
    *   Топики (основные): `player_sessions_history`, `tank_coordinates_history`, `game_events`, `auth_events`.
6.  **RabbitMQ (Брокер сообщений):**
    *   Назначение: Обработка асинхронных команд игроков и событий матчмейкинга.
    *   Очереди (основные): `player_commands`, `matchmaking_events`.
7.  **Redis:**
    *   Назначение: Кэширование, хранение временных данных сессий (если необходимо).
    *   (Описание без изменений)
8.  **Prometheus:** (Описание без изменений)
9.  **Grafana:** (Описание без изменений)
10. **База данных (PostgreSQL - концептуально):** (Описание без изменений)

### Обновленный Поток Команд и Событий

С внедрением Kafka и RabbitMQ поток обработки команд и логирования событий изменился:

1.  **Обработка Команд Игрока (например, "shoot", "move"):**
    *   Клиент игры отправляет команду (по TCP или UDP) на соответствующий обработчик Игрового Сервера (`tcp_handler.py` или `udp_handler.py`).
    *   Обработчик формирует сообщение команды и публикует его в очередь `player_commands` в RabbitMQ.
    *   `PlayerCommandConsumer` (в `game_server/command_consumer.py`) получает команду из очереди.
    *   Consumer вызывает соответствующий метод игровой логики (например, `tank.shoot()` или `tank.move()`).

2.  **Обработка Событий Матчмейкинга:**
    *   Предполагается, что внешний сервис матчмейкинга (не входит в этот прототип) публикует событие о создании нового матча (например, `new_match_created`) в очередь `matchmaking_events` в RabbitMQ.
    *   `MatchmakingEventConsumer` (в `game_server/command_consumer.py`) получает это событие.
    *   Consumer вызывает `SessionManager` для создания новой игровой сессии.

3.  **Логирование Событий и Данных в Kafka:**
    *   **События сессий:** `SessionManager` при создании сессии (`session_created`), удалении сессии (`session_removed`), присоединении игрока (`player_joined_session`) или выходе игрока (`player_left_session`) отправляет соответствующие события в топик `player_sessions_history` в Kafka.
    *   **Координаты танков:** Метод `tank.move()` после обновления позиции танка отправляет событие `tank_moved` с новыми координатами в топик `tank_coordinates_history` в Kafka.
    *   **Игровые события:** Методы класса `Tank` (например, `shoot()`, `take_damage()`) отправляют события `tank_shot`, `tank_took_damage`, `tank_destroyed` в топик `game_events` в Kafka.
    *   **События аутентификации:** Сервер аутентификации отправляет события (например, `user_logged_in`, `user_login_failed`) в топик `auth_events` в Kafka.

Эта архитектура с брокерами сообщений позволяет повысить отказоустойчивость, масштабируемость и гибкость системы, а также обеспечивает централизованное логирование для последующего анализа и построения аналитики.

### Структура проекта

(Обновить описания `game_server/` и `core/` при необходимости)
- `auth_server/`: Код сервера аутентификации.
  - ...
  - `event_publishers.py` (если есть): Логика отправки событий в Kafka.
- `game_server/`: Код игрового сервера.
  - `main.py`: Точка входа, запуск UDP/TCP серверов, инициализация консьюмеров.
  - `udp_handler.py`, `tcp_handler.py`: Обработка входящих команд, публикация в RabbitMQ.
  - `command_consumer.py`: Содержит `PlayerCommandConsumer` и `MatchmakingEventConsumer`.
  - `session_manager.py`: Управление игровыми сессиями, отправка событий сессий в Kafka.
  - `tank_pool.py`: Управление объектами танков.
  - `tank.py`: Класс, представляющий танк, отправка событий танка в Kafka.
  - `metrics.py`: Определения метрик Prometheus.
- `core/`: Общие модули.
  - `message_broker_clients.py`: Клиенты для Kafka и RabbitMQ, определения имен топиков/очередей.
  - `redis_client.py` (если есть).
- `tests/`: Юнит и нагрузочные тесты.
  - `unit/`: Юнит-тесты (`pytest`), включая тесты для консьюмеров и обработчиков.
- (Остальные секции структуры проекта без изменений)

## Требования

- Python 3.9+
- Docker
- `docker-compose` (для локального запуска брокеров и мониторинга)
- `kubectl` (для развертывания в Kubernetes)
- Доступ к кластеру Kubernetes (например, Minikube, Kind, или облачный EKS, GKE, AKS)
- `locust` (для запуска нагрузочных тестов)
- `netcat` (`nc`) или `telnet` (для ручного тестирования TCP/UDP)

## Настройка и запуск на Windows

Для работы с проектом на Windows рекомендуется следующая конфигурация и шаги:

### 1. Установка Docker Desktop

*   **Скачайте и установите Docker Desktop для Windows** с официального сайта Docker: [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)
*   Docker Desktop позволит вам запускать контейнеры с Kafka, RabbitMQ и другими сервисами, а также сами серверы приложений, если они упакованы в Docker-образы.
*   **Рекомендация WSL2:** При установке Docker Desktop выберите бэкенд WSL2 (Windows Subsystem for Linux 2), если ваша версия Windows это поддерживает. WSL2 обеспечивает лучшую производительность и совместимость для Docker. Следуйте инструкциям Docker Desktop для настройки WSL2.

### 2. Установка Git
*   Если у вас еще не установлен Git, скачайте и установите его с [https://git-scm.com/download/win](https://git-scm.com/download/win).
*   Git необходим для клонирования репозитория.

### 3. Клонирование репозитория
*   Откройте командную строку (CMD), PowerShell или Git Bash.
*   Перейдите в каталог, куда вы хотите склонировать проект, и выполните команду:
    ```bash
    git clone https://<URL_вашего_репозитория>.git
    cd <имя_папки_репозитория>
    ```
    *(Замените `<URL_вашего_репозитория>` и `<имя_папки_репозитория>` на актуальные значения).*

Дальнейшие шаги по установке зависимостей Python, настройке брокеров сообщений и запуску серверов описаны в соответствующих разделах ниже. Этот раздел предоставляет базовые шаги для подготовки Windows-окружения.

## Message Broker Setup (Kafka & RabbitMQ)

Для обработки асинхронных команд игроков, событий матчмейкинга и логирования игровых событий в систему интегрированы Kafka и RabbitMQ.

### Локальный запуск (Docker Compose)

Убедитесь, что у вас установлен и запущен Docker Desktop для Windows.
Файл `docker-compose.yml` в корне проекта был обновлен и теперь включает конфигурации для Zookeeper, Kafka и RabbitMQ. Для их локального запуска вместе с другими сервисами мониторинга, откройте терминал (PowerShell или CMD) в корневой папке проекта и выполните:

```bash
docker-compose up -d

Если вы хотите запустить только брокеры сообщений (например, если серверы приложений запускаются локально вне Docker), используйте:

docker-compose up -d zookeeper kafka rabbitmq

Это запустит:

    Zookeeper: Необходим для Kafka. Доступен внутри Docker сети по zookeeper:2181.
    Kafka: Используется для логирования событий игры, сессий игроков и координат танков.
        Доступен внутри Docker сети по адресу kafka:9092 (для клиентов, работающих в других контейнерах Docker, например, auth_server, game_server если они запущены через docker-compose).
        Доступен с хост-машины Windows по адресу localhost:29092.
    RabbitMQ: Используется для передачи команд от игроков и событий матчмейкинга.
        Доступен внутри Docker сети по адресу rabbitmq:5672.
        Веб-интерфейс управления RabbitMQ доступен с хост-машины Windows по адресу http://localhost:15672 (логин/пароль по умолчанию: user/password).

Примечание для Windows: При первом запуске контейнеров, Docker может запросить разрешение на доступ через Брандмауэр Windows для открываемых портов. Предоставьте необходимое разрешение.

Для просмотра логов запущенных через docker-compose сервисов (например, Kafka, RabbitMQ), используйте команду docker-compose logs <имя_сервиса> (например, docker-compose logs kafka). Пользователи Windows также могут просматривать логи контейнеров через графический интерфейс Docker Desktop.
Kubernetes

Для развертывания в Kubernetes рекомендуется использовать стабильные Helm-чарты для Kafka (например, от Bitnami или Confluent) и RabbitMQ (например, от Bitnami). Это обеспечит надежную и масштабируемую установку. Конфигурация приложений (Deployment'ы серверов аутентификации и игры) должна быть обновлена для подключения к этим сервисам в Kubernetes.
Environment Variables

Следующие переменные окружения используются для настройки подключения к Kafka и RabbitMQ:

    KAFKA_BOOTSTRAP_SERVERS:
        Описание: Список адресов брокеров Kafka через запятую.
        Пример: kafka:9092 (при использовании Docker Compose из этого проекта для связи между контейнерами), localhost:29092 (для доступа с хост-машины к Kafka в Docker).
        Значение по умолчанию: localhost:9092 (если переменная не установлена, но для Docker окружения следует явно указывать имя сервиса kafka:9092).
        Используется: auth_server, game_server (и другие компоненты, логирующие в Kafka).

    RABBITMQ_HOST:
        Описание: Имя хоста или IP-адрес сервера RabbitMQ.
        Пример: rabbitmq (при использовании Docker Compose из этого проекта).
        Значение по умолчанию: localhost (если переменная не установлена).
        Используется: game_server (для PlayerCommandConsumer и MatchmakingEventConsumer).

Установка зависимостей

pip install -r requirements.txt 
# Убедитесь, что kafka-python и pika добавлены в requirements.txt с нужными версиями

Локальный запуск серверов (для разработки)
Предварительная настройка Python на Windows (для локального запуска серверов)

Если вы планируете запускать серверы приложений (auth_server, game_server) непосредственно на Windows (а не в Docker-контейнерах), вам потребуется настроить Python:

    Установите Python:
        Скачайте последнюю стабильную версию Python для Windows с https://www.python.org/downloads/windows/.
        Во время установки обязательно отметьте галочку "Add Python to PATH". Это упростит запуск Python из командной строки.

    Создайте и активируйте виртуальное окружение:
        Откройте терминал (PowerShell или CMD) в корневой папке проекта.
        Выполните команду для создания виртуального окружения (например, с именем venv):

        python -m venv venv

        Активируйте виртуальное окружение:
            В PowerShell:

            .\venv\Scripts\Activate.ps1

            (Если выполнение скриптов PowerShell запрещено, вам может потребоваться выполнить Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Unrestricted один раз, а затем вернуть обратно, если необходимо.)
            В CMD:

            .\venv\Scripts\activate.bat

        После активации в начале командной строки появится префикс (venv).

    Установите зависимости:
        Находясь в активированном виртуальном окружении, установите необходимые пакеты:

        pip install -r requirements.txt

Настройка переменных окружения на Windows (для локального запуска)

Перед запуском серверов локально, убедитесь, что переменные окружения для подключения к Kafka и RabbitMQ установлены. Если Kafka и RabbitMQ запущены через Docker Desktop, как описано выше, используйте следующие значения:

    Для PowerShell:

    $env:KAFKA_BOOTSTRAP_SERVERS="localhost:29092"
    $env:RABBITMQ_HOST="localhost"
    # Эти переменные будут установлены только для текущей сессии PowerShell.
    # Для постоянной установки используйте системные настройки переменных окружения Windows.

    Для CMD:

    set KAFKA_BOOTSTRAP_SERVERS=localhost:29092
    set RABBITMQ_HOST=localhost
    # Эти переменные будут установлены только для текущей сессии CMD.

Вы также можете установить их глобально через "Панель управления" -> "Система и безопасность" -> "Система" -> "Дополнительные параметры системы" -> "Переменные среды".

Перед запуском серверов приложений убедитесь, что Kafka и RabbitMQ запущены (см. секцию "Message Broker Setup").

Сервер аутентификации:

Убедитесь, что ваше виртуальное окружение активировано и переменные окружения установлены. Для запуска из корневой папки проекта:

python -m auth_server.main

Сервер будет доступен по TCP на localhost:8888. Метрики Prometheus на http://localhost:8000/metrics.

Игровой сервер:

Убедитесь, что ваше виртуальное окружение активировано и переменные окружения установлены. Для запуска из корневой папки проекта:

python -m game_server.main

Сервер будет доступен по UDP на localhost:9999. Метрики Prometheus на http://localhost:8001/metrics.

Логи для серверов, запущенных напрямую в консоли Windows (PowerShell или CMD), будут выводиться непосредственно в окно этой консоли.
Ручное тестирование и отладка

(Эта секция в основном остается без изменений, но стоит помнить, что команды теперь идут через RabbitMQ, поэтому прямая реакция танка в логах игрового сервера на команду move или shoot от nc будет отсутствовать. Вместо этого нужно смотреть логи консьюмера команд.)

(Остальные секции: "Сборка и запуск с Docker", "Развертывание в Kubernetes", "Мониторинг" остаются в основном без изменений, но могут потребовать мелких корректировок в контексте новых зависимостей, например, в Dockerfile или Kubernetes манифестах для передачи переменных окружения.)
Тестирование

Для запуска всех юнит-тестов, находясь в корневой директории проекта и активировав виртуальное окружение, выполните:

python -m pytest tests/unit/ -v -s

Или, используя стандартный unittest discovery:

python -m unittest discover tests/unit

Также отдельные файлы с тестами могут быть запущены как обычные Python скрипты, если они содержат соответствующий блок if __name__ == '__main__': unittest.main().
Запуск и отладка юнит-тестов

В проекте используется стандартная библиотека unittest для написания и запуска юнит-тестов. Файлы тестов находятся в директории tests/unit/.

Индивидуальный запуск тестов:

Для более детальной диагностики и отладки рекомендуется запускать тесты для конкретного файла напрямую. Это можно сделать из корневой директории проекта с помощью команды:

python -m unittest tests/unit/имя_файла_теста.py

Например:

python -m unittest tests/unit/test_tcp_handler_game.py

Такой подход позволяет увидеть вывод (включая логи) только от интересующего набора тестов, что упрощает анализ.

Особенности мокирования асинхронного кода:

При тестировании асинхронных компонентов, особенно тех, что взаимодействуют с сетевыми операциями (например, asyncio.StreamReader, asyncio.StreamWriter), могут возникнуть следующие нюансы:

    Завершение асинхронных задач: Некоторые асинхронные функции могут порождать фоновые задачи, которые не успевают завершиться до выполнения ассертов в тесте. Чтобы дать этим задачам шанс выполниться, можно использовать await asyncio.sleep(0) непосредственно перед проверками:

    # ... (код вызова тестируемой асинхронной функции)
    await handle_game_client(mock_reader, mock_writer, mock_game_room)
    await asyncio.sleep(0) # Даем время на выполнение всех запланированных задач
    mock_publish_rabbitmq.assert_any_call(...) 

    Мокирование asyncio.StreamWriter: При использовании unittest.mock.AsyncMock для имитации asyncio.StreamWriter, его метод is_closing() по умолчанию может возвращать не то значение, которое ожидает тестируемый код (например, если код проверяет writer.is_closing() в цикле). Чтобы избежать преждевременного выхода из циклов, можно явно задать возвращаемое значение:

    mock_writer = AsyncMock(spec=asyncio.StreamWriter)
    mock_writer.is_closing.return_value = False 

    Контролируемое завершение чтения из asyncio.StreamReader: При мокировании StreamReader.readuntil(), чтобы симулировать последовательность входящих данных и затем корректно завершить чтение (например, для выхода из цикла while True в обработчике), можно использовать ConnectionResetError() в качестве одного из значений side_effect:

    mock_reader.readuntil.side_effect = [
        b"LOGIN user pass\n", 
        b"SOME_COMMAND\n",
        ConnectionResetError() # Сигнализирует о "разрыве" соединения
    ]

    Это более надежный способ завершения, чем, например, asyncio.IncompleteReadError, так как он обычно обрабатывается в блоках except сетевого кода.

Особенности мокирования зависимостей при инициализации объекта (в setUp):

Если тестируемый объект при своей инициализации (например, в __init__) обращается к внешним зависимостям (например, пытается установить сетевое соединение), то стандартные декораторы @patch или @patch.object на тестовых методах не успеют сработать для конструктора. Чтобы предотвратить реальные вызовы во время создания объекта в setUp, можно использовать patcher.start() и addCleanup(patcher.stop):

class TestMyConsumer(unittest.TestCase):
    def setUp(self):
        # Патчим зависимость ДО создания экземпляра
        self.patcher_dependency = patch('path.to.dependency')
        self.mock_dependency_for_setup = self.patcher_dependency.start()
        self.addCleanup(self.patcher_dependency.stop) # Гарантирует остановку патча

        # Патчим метод самого класса (если он вызывается в __init__)
        # Используем БЕЗ autospec в setUp, чтобы избежать InvalidSpecError при повторном патчинге на методе
        self.patcher_method = patch.object(MyConsumerClass, '_internal_method_called_by_init')
        self.mock_internal_method_for_setup = self.patcher_method.start()
        self.addCleanup(self.patcher_method.stop)

        self.consumer = MyConsumerClass() # Теперь конструктор использует моки

    # На тестовых методах можно использовать свои декораторы @patch, 
    # они создадут отдельные моки для самого теста.
    @patch.object(MyConsumerClass, '_internal_method_called_by_init', autospec=True)
    @patch('path.to.dependency')
    def test_something(self, mock_dependency_for_test, mock_internal_method_for_test):
        # ...

В этом примере, autospec=True используется на декораторе метода для более строгих проверок, в то время как в setUp для patch.object он может быть опущен, если его задача - только "заглушить" метод на время инициализации.

Важно при отладке: Если вы сталкиваетесь с ошибками в тестах, которые не удается воспроизвести или понять по стандартным логам pytest или unittest, убедитесь, что:

    Кеш pytest очищен: Удалите папку .pytest_cache.
    Локальные изменения соответствуют репозиторию: Если вы работаете со мной или в команде, убедитесь, что анализируемый и изменяемый код актуален. В случае расхождений, может потребоваться ручная замена содержимого файла на версию, предложенную для исправления, чтобы гарантировать применение изменений.
    Логгирование настроено: Для вывода подробной информации из тестируемых модулей, убедитесь, что логгирование настроено на достаточный уровень (например, DEBUG или INFO) в ваших тестовых файлах или глобально:

    import logging
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(name)s - %(module)s - %(message)s')

Резервное копирование Redis

(Этот раздел, если он существует, остается без изменений)
Дальнейшие улучшения и TODO

    ...
    Интеграция с системой матчмейкинга для отправки событий new_match_created в RabbitMQ.
    Разработка клиентов или сервисов, которые будут читать из Kafka для аналитики, мониторинга аномалий, и т.д.
    ...
