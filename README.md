# Серверная архитектура Tanks Blitz (Прототип)

Этот проект представляет собой прототип серверной архитектуры для многопользовательской игры Tanks Blitz, разработанный на Python.
Он включает компоненты для аутентификации, игровой логики, обработки команд через брокеры сообщений, масштабирования, мониторинга и резервного копирования.

## Обзор проекта

Цель проекта - продемонстрировать построение серверной части для MMO-игры с учетом современных практик и технологий, таких как:
- Разделение сервисов (аутентификация, игра)
- Асинхронное программирование и обработка событий
- Брокеры сообщений (Kafka, RabbitMQ) для асинхронных задач и логирования
- Паттерны проектирования (Singleton, Object Pool)
- Контейнеризация (Docker)
- Оркестрация (Kubernetes)
- Мониторинг (Prometheus, Grafana)
- Защита от DDoS (Nginx)
- Резервное копирование (Redis)

## Архитектура

Система состоит из следующих основных компонентов:

1.  **Клиент Игры** (не входит в этот репозиторий)
2.  **Nginx (Входная точка/Балансировщик/Защита от DDoS):**
    *   Принимает весь трафик от клиентов.
    *   Проксирует TCP-трафик на Сервер Аутентификации.
    *   Проксирует UDP-трафик на Игровой Сервер.
    *   Может быть настроен для базовой защиты от DDoS.
    *   Разворачивается в Kubernetes.
3.  **Сервер Аутентификации (Auth Server):**
    *   **Протокол: TCP, JSON.** (Описание без изменений)
    *   Назначение: Регистрация и аутентификация. Отправляет события аудита в Kafka.
    *   Технологии: Python, `asyncio`, Kafka-клиент.
    *   Экспортирует метрики для Prometheus на порт `8000`.
4.  **Игровой Сервер (Game Server):**
    *   **Протокол: UDP (основной игровой), TCP (управляющие команды). Сообщения в формате JSON.** (Описание без изменений)
    *   Назначение: Обработка игровой логики, синхронизация состояния игры. Взаимодействует с RabbitMQ для получения команд игроков и событий матчмейкинга. Отправляет события состояния игры и данные в Kafka.
    *   Паттерны: `SessionManager` (Singleton), `TankPool` (Object Pool).
    *   Компоненты:
        *   `udp_handler.py`, `tcp_handler.py`: Обработка входящих команд, публикация в RabbitMQ.
        *   `command_consumer.py`: Содержит `PlayerCommandConsumer` (обработка команд из RabbitMQ) и `MatchmakingEventConsumer` (обработка событий матчмейкинга из RabbitMQ).
        *   `session_manager.py`, `tank_pool.py`, `tank.py`: Основная игровая логика, отправка событий в Kafka.
    *   Технологии: Python, `asyncio`, Kafka-клиент, Pika (RabbitMQ-клиент).
    *   Экспортирует метрики для Prometheus на порт `8001`.
5.  **Kafka (Брокер сообщений):**
    *   Назначение: Сбор и хранение событий от различных компонентов системы для логирования, аналитики и потенциальной последующей обработки.
    *   Топики (основные): `player_sessions_history`, `tank_coordinates_history`, `game_events`, `auth_events`.
6.  **RabbitMQ (Брокер сообщений):**
    *   Назначение: Обработка асинхронных команд игроков и событий матчмейкинга.
    *   Очереди (основные): `player_commands`, `matchmaking_events`.
7.  **Redis:**
    *   Назначение: Кэширование, хранение временных данных сессий (если необходимо).
    *   (Описание без изменений)
8.  **Prometheus:** (Описание без изменений)
9.  **Grafana:** (Описание без изменений)
10. **База данных (PostgreSQL - концептуально):** (Описание без изменений)

### Обновленный Поток Команд и Событий

С внедрением Kafka и RabbitMQ поток обработки команд и логирования событий изменился:

1.  **Обработка Команд Игрока (например, "shoot", "move"):**
    *   Клиент игры отправляет команду (по TCP или UDP) на соответствующий обработчик Игрового Сервера (`tcp_handler.py` или `udp_handler.py`).
    *   Обработчик формирует сообщение команды и публикует его в очередь `player_commands` в RabbitMQ.
    *   `PlayerCommandConsumer` (в `game_server/command_consumer.py`) получает команду из очереди.
    *   Consumer вызывает соответствующий метод игровой логики (например, `tank.shoot()` или `tank.move()`).

2.  **Обработка Событий Матчмейкинга:**
    *   Предполагается, что внешний сервис матчмейкинга (не входит в этот прототип) публикует событие о создании нового матча (например, `new_match_created`) в очередь `matchmaking_events` в RabbitMQ.
    *   `MatchmakingEventConsumer` (в `game_server/command_consumer.py`) получает это событие.
    *   Consumer вызывает `SessionManager` для создания новой игровой сессии.

3.  **Логирование Событий и Данных в Kafka:**
    *   **События сессий:** `SessionManager` при создании сессии (`session_created`), удалении сессии (`session_removed`), присоединении игрока (`player_joined_session`) или выходе игрока (`player_left_session`) отправляет соответствующие события в топик `player_sessions_history` в Kafka.
    *   **Координаты танков:** Метод `tank.move()` после обновления позиции танка отправляет событие `tank_moved` с новыми координатами в топик `tank_coordinates_history` в Kafka.
    *   **Игровые события:** Методы класса `Tank` (например, `shoot()`, `take_damage()`) отправляют события `tank_shot`, `tank_took_damage`, `tank_destroyed` в топик `game_events` в Kafka.
    *   **События аутентификации:** Сервер аутентификации отправляет события (например, `user_logged_in`, `user_login_failed`) в топик `auth_events` в Kafka.

Эта архитектура с брокерами сообщений позволяет повысить отказоустойчивость, масштабируемость и гибкость системы, а также обеспечивает централизованное логирование для последующего анализа и построения аналитики.

### Структура проекта

(Обновить описания `game_server/` и `core/` при необходимости)
- `auth_server/`: Код сервера аутентификации.
  - ...
  - `event_publishers.py` (если есть): Логика отправки событий в Kafka.
- `game_server/`: Код игрового сервера.
  - `main.py`: Точка входа, запуск UDP/TCP серверов, инициализация консьюмеров.
  - `udp_handler.py`, `tcp_handler.py`: Обработка входящих команд, публикация в RabbitMQ.
  - `command_consumer.py`: Содержит `PlayerCommandConsumer` и `MatchmakingEventConsumer`.
  - `session_manager.py`: Управление игровыми сессиями, отправка событий сессий в Kafka.
  - `tank_pool.py`: Управление объектами танков.
  - `tank.py`: Класс, представляющий танк, отправка событий танка в Kafka.
  - `metrics.py`: Определения метрик Prometheus.
- `core/`: Общие модули.
  - `message_broker_clients.py`: Клиенты для Kafka и RabbitMQ, определения имен топиков/очередей.
  - `redis_client.py` (если есть).
- `tests/`: Юнит и нагрузочные тесты.
  - `unit/`: Юнит-тесты (`pytest`), включая тесты для консьюмеров и обработчиков.
- (Остальные секции структуры проекта без изменений)

## Требования

- Python 3.9+
- Docker
- `docker-compose` (для локального запуска брокеров и мониторинга)
- `kubectl` (для развертывания в Kubernetes)
- Доступ к кластеру Kubernetes (например, Minikube, Kind, или облачный EKS, GKE, AKS)
- `locust` (для запуска нагрузочных тестов)
- `netcat` (`nc`) или `telnet` (для ручного тестирования TCP/UDP)

## Message Broker Setup (Kafka & RabbitMQ)

Для обработки асинхронных команд игроков, событий матчмейкинга и логирования игровых событий в систему интегрированы Kafka и RabbitMQ.

### Локальный запуск (Docker Compose)

Файл `docker-compose.yml` в корне проекта был обновлен и теперь включает конфигурации для Zookeeper, Kafka и RabbitMQ. Для их локального запуска вместе с другими сервисами мониторинга:

```bash
docker-compose up -d
```
Если вы хотите запустить только брокеры сообщений (например, если серверы приложений запускаются локально вне Docker), используйте:
```bash
docker-compose up -d zookeeper kafka rabbitmq
```
Это запустит:
- **Zookeeper:** Необходим для Kafka. Доступен внутри Docker сети по `zookeeper:2181`.
- **Kafka:** Используется для логирования событий игры, сессий игроков и координат танков. Доступен внутри Docker сети по адресу `kafka:9092` (для клиентов внутри Docker) и `localhost:29092` (для клиентов с хост-машины).
- **RabbitMQ:** Используется для передачи команд от игроков и событий матчмейкинга. Доступен внутри Docker сети по адресу `rabbitmq:5672`, менеджмент-консоль на `http://localhost:15672` (логин/пароль по умолчанию: `user`/`password`).

### Kubernetes

Для развертывания в Kubernetes рекомендуется использовать стабильные Helm-чарты для Kafka (например, от Bitnami или Confluent) и RabbitMQ (например, от Bitnami). Это обеспечит надежную и масштабируемую установку. Конфигурация приложений (Deployment'ы серверов аутентификации и игры) должна быть обновлена для подключения к этим сервисам в Kubernetes.

## Environment Variables

Следующие переменные окружения используются для настройки подключения к Kafka и RabbitMQ:

-   **`KAFKA_BOOTSTRAP_SERVERS`**:
    -   Описание: Список адресов брокеров Kafka через запятую.
    -   Пример: `kafka:9092` (при использовании Docker Compose из этого проекта для связи между контейнерами), `localhost:29092` (для доступа с хост-машины к Kafka в Docker).
    -   Значение по умолчанию: `localhost:9092` (если переменная не установлена, но для Docker окружения следует явно указывать имя сервиса `kafka:9092`).
    -   Используется: `auth_server`, `game_server` (и другие компоненты, логирующие в Kafka).

-   **`RABBITMQ_HOST`**:
    -   Описание: Имя хоста или IP-адрес сервера RabbitMQ.
    -   Пример: `rabbitmq` (при использовании Docker Compose из этого проекта).
    -   Значение по умолчанию: `localhost` (если переменная не установлена).
    -   Используется: `game_server` (для `PlayerCommandConsumer` и `MatchmakingEventConsumer`).

## Установка зависимостей

```bash
pip install -r requirements.txt 
# Убедитесь, что kafka-python и pika добавлены в requirements.txt с нужными версиями
```

## Локальный запуск серверов (для разработки)

**Перед запуском серверов приложений убедитесь, что Kafka и RabbitMQ запущены (см. секцию "Message Broker Setup").**

**Сервер аутентификации:**
(Команды и описание без изменений)

**Игровой сервер:**
(Команды и описание без изменений)

## Ручное тестирование и отладка
(Эта секция в основном остается без изменений, но стоит помнить, что команды теперь идут через RabbitMQ, поэтому прямая реакция танка в логах игрового сервера на команду `move` или `shoot` от `nc` будет отсутствовать. Вместо этого нужно смотреть логи консьюмера команд.)

(Остальные секции: "Сборка и запуск с Docker", "Развертывание в Kubernetes", "Мониторинг", "Тестирование", "Резервное копирование Redis", "Дальнейшие улучшения и TODO" остаются в основном без изменений, но могут потребовать мелких корректировок в контексте новых зависимостей, например, в Dockerfile или Kubernetes манифестах для передачи переменных окружения.)

## Дальнейшие улучшения и TODO
- ...
- **Интеграция с системой матчмейкинга** для отправки событий `new_match_created` в RabbitMQ.
- **Разработка клиентов или сервисов, которые будут читать из Kafka** для аналитики, мониторинга аномалий, и т.д.
- ...

[end of README.md]
